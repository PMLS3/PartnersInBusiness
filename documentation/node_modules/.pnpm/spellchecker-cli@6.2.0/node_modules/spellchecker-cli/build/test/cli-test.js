/* eslint-disable @typescript-eslint/no-non-null-assertion */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
import { exec } from 'child_process';
import { readFileSync, rmSync, writeFileSync } from 'fs';
import chai from 'chai';
import glob from 'globby';
import merge from 'lodash/merge.js';
import parallel from 'mocha.parallel';
import { addPlugins, defaultPlugins, removePlugins, supportedLanguages, supportedPlugins, } from '../lib/config/command-line.js';
chai.should();
function runCommand(command) {
    return new Promise(function (resolve) {
        exec(command, {}, function (error, stdout, stderr) {
            if (error) {
                resolve(merge({}, error, { stdout: stdout, stderr: stderr }));
            }
            resolve({ stdout: stdout, stderr: stderr });
        });
    });
}
function runWithArguments(args) {
    return runCommand("node build/index.js ".concat(args));
}
var notSpell = function (plugin) { return plugin !== 'spell'; };
var nonSpellPlugins = supportedPlugins.filter(notSpell);
var nonSpellAddPlugins = addPlugins.filter(notSpell);
var nonSpellRemovePlugins = removePlugins.filter(notSpell);
var toSpaceAndHyphenSplitRegex = function (word) {
    return word.replace(/ /g, '\\s*').replace(/-/g, '-\\s*');
};
parallel('Spellchecker CLI', function testSpellcheckerCLI() {
    var _this = this;
    this.timeout(5 * 60 * 1000);
    this.slow(5 * 60 * 1000);
    it('prints the command-line usage when the argument `-h` is passed', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('-h')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    result.stdout.should.include('A command-line tool for spellchecking files.');
                    return [2 /*return*/];
            }
        });
    }); });
    it('prints the command-line usage when the argument `--help` is passed', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('--help')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    result.stdout.should.include('A command-line tool for spellchecking files.');
                    return [2 /*return*/];
            }
        });
    }); });
    it('prints the default language in the command-line usage', function () { return __awaiter(_this, void 0, void 0, function () {
        var stdout, defaultLanguageRegex;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('--help')];
                case 1:
                    stdout = (_a.sent()).stdout;
                    defaultLanguageRegex = new RegExp(toSpaceAndHyphenSplitRegex('The default language is en-US.'));
                    stdout.should.match(defaultLanguageRegex);
                    return [2 /*return*/];
            }
        });
    }); });
    it('lists all supported languages in the command-line usage', function () { return __awaiter(_this, void 0, void 0, function () {
        var stdout, languageRegex;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('-h')];
                case 1:
                    stdout = (_a.sent()).stdout;
                    languageRegex = new RegExp(supportedLanguages.map(toSpaceAndHyphenSplitRegex).join(',\\s*'));
                    stdout.should.match(languageRegex);
                    return [2 /*return*/];
            }
        });
    }); });
    it('prints the default plugin list in the command-line usage', function () { return __awaiter(_this, void 0, void 0, function () {
        var stdout, defaultPluginsRegex;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('--help')];
                case 1:
                    stdout = (_a.sent()).stdout;
                    defaultPluginsRegex = new RegExp(toSpaceAndHyphenSplitRegex("The default is \"".concat(defaultPlugins.join(' '), "\".")));
                    stdout.should.match(defaultPluginsRegex);
                    return [2 /*return*/];
            }
        });
    }); });
    it('lists all supported plugins in the command-line usage', function () { return __awaiter(_this, void 0, void 0, function () {
        var stdout, pluginRegex;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('-h')];
                case 1:
                    stdout = (_a.sent()).stdout;
                    pluginRegex = new RegExp(supportedPlugins.map(toSpaceAndHyphenSplitRegex).join(',\\s*'));
                    stdout.should.match(pluginRegex);
                    return [2 /*return*/];
            }
        });
    }); });
    it('exits with an error when an empty config file is specified', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stderr;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('--config test/fixtures/config/empty.yml')];
                case 1:
                    _a = _b.sent(), code = _a.code, stderr = _a.stderr;
                    code.should.equal(1);
                    stderr.should.include('A list of files is required.');
                    return [2 /*return*/];
            }
        });
    }); });
    it('exits with an error when an empty list of files is provided', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stderr;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('--files')];
                case 1:
                    _a = _b.sent(), code = _a.code, stderr = _a.stderr;
                    code.should.equal(1);
                    stderr.should.include('A list of files is required.');
                    return [2 /*return*/];
            }
        });
    }); });
    it('exits with an error when passed an unknown argument', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stderr;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('--test')];
                case 1:
                    _a = _b.sent(), code = _a.code, stderr = _a.stderr;
                    code.should.equal(1);
                    stderr.should.include('UNKNOWN_OPTION: Unknown option: --test');
                    return [2 /*return*/];
            }
        });
    }); });
    it('exits with an error when passed an unknown language', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stderr;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('--files a b c --language test')];
                case 1:
                    _a = _b.sent(), code = _a.code, stderr = _a.stderr;
                    code.should.equal(1);
                    stderr.should.include('The language "test" is not supported.');
                    return [2 /*return*/];
            }
        });
    }); });
    it('exits with an error when run on a file with a spelling mistake', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stdout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/incorrect.txt')];
                case 1:
                    _a = _b.sent(), code = _a.code, stdout = _a.stdout;
                    code.should.equal(1);
                    stdout.should.include('`Thisisnotaword` is misspelt');
                    return [2 /*return*/];
            }
        });
    }); });
    it('exits with no error when run on a file with no spelling mistakes', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('--files test/fixtures/correct.txt')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('exits with an error when run with a dictionary that does not contain the words in the given file', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stdout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/en-CA.txt')];
                case 1:
                    _a = _b.sent(), code = _a.code, stdout = _a.stdout;
                    code.should.equal(1);
                    ['Colour', 'honour', 'behaviour'].forEach(function (word) {
                        stdout.should.include("`".concat(word, "` is misspelt"));
                    });
                    return [2 /*return*/];
            }
        });
    }); });
    it('exits with no error when run with a dictionary that contains the words in the given file', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('-f test/fixtures/en-CA.txt -l en-CA')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('handles Markdown syntax', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stdout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('--files test/fixtures/markdown.md')];
                case 1:
                    _a = _b.sent(), code = _a.code, stdout = _a.stdout;
                    code.should.equal(1);
                    ['Spellig', 'paragrap', 'containin', 'mistaks', 'Bullts', 'Moar'].forEach(function (word) {
                        stdout.should.include("`".concat(word, "` is misspelt"));
                    });
                    return [2 /*return*/];
            }
        });
    }); });
    it('handles MDX syntax', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stdout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('--files test/fixtures/markdown.mdx')];
                case 1:
                    _a = _b.sent(), code = _a.code, stdout = _a.stdout;
                    code.should.equal(1);
                    ['Spellig', 'paragrap', 'containin', 'mistaks', 'Bullts', 'Moar'].forEach(function (word) {
                        stdout.should.include("`".concat(word, "` is misspelt"));
                    });
                    return [2 /*return*/];
            }
        });
    }); });
    it('ignores spelling mistakes in code blocks', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('-f test/fixtures/code-blocks.md')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('ignores Gemoji', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('-f test/fixtures/gemoji.md')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('ignores HTML tables', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('--files test/fixtures/table.md')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('ignores words in the provided dictionary file', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/incorrect.txt --dictionaries test/fixtures/dictionaries/one.txt')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('does not spellcheck the provided dictionary file', function () { return __awaiter(_this, void 0, void 0, function () {
        var stdout;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('-f test/fixtures/*.txt -d test/fixtures/dictionaries/one.txt')];
                case 1:
                    stdout = (_a.sent()).stdout;
                    stdout.should.not.contain('test/fixtures/dictionaries/one.txt');
                    return [2 /*return*/];
            }
        });
    }); });
    it('spellchecks all files in a glob', function () { return __awaiter(_this, void 0, void 0, function () {
        var stdout, fileNames;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    // `--no-suggestions` to reduce chance of timeout, but also increase timeout for this one test
                    this.timeout(7500);
                    return [4 /*yield*/, runWithArguments('test/fixtures/* --no-suggestions')];
                case 1:
                    stdout = (_a.sent()).stdout;
                    return [4 /*yield*/, glob('*', { cwd: 'test/fixtures' })];
                case 2:
                    fileNames = _a.sent();
                    fileNames.forEach(function (fileName) {
                        stdout.should.contain("test/fixtures/".concat(fileName));
                    });
                    return [2 /*return*/];
            }
        });
    }); });
    it('runs in quiet mode when the argument `-q` is passed', function () { return __awaiter(_this, void 0, void 0, function () {
        var stdout;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('--files test/fixtures/correct.txt -q')];
                case 1:
                    stdout = (_a.sent()).stdout;
                    stdout.should.equal('');
                    return [2 /*return*/];
            }
        });
    }); });
    it('runs in quiet mode when the argument `--quiet` is passed', function () { return __awaiter(_this, void 0, void 0, function () {
        var stdout;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('--files test/fixtures/correct.txt --quiet')];
                case 1:
                    stdout = (_a.sent()).stdout;
                    stdout.should.equal('');
                    return [2 /*return*/];
            }
        });
    }); });
    it('prints errors in quiet mode', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stdout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('--files test/fixtures/incorrect.txt --quiet')];
                case 1:
                    _a = _b.sent(), code = _a.code, stdout = _a.stdout;
                    code.should.equal(1);
                    stdout.should.include('`Thisisnotaword` is misspelt');
                    return [2 /*return*/];
            }
        });
    }); });
    it('prints the number of files to be spellchecked when passed one file', function () { return __awaiter(_this, void 0, void 0, function () {
        var stdout;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('--files test/fixtures/correct.txt')];
                case 1:
                    stdout = (_a.sent()).stdout;
                    stdout.should.include('Spellchecking 1 file...');
                    return [2 /*return*/];
            }
        });
    }); });
    it('prints the number of files to be spellchecked when passed a glob', function () { return __awaiter(_this, void 0, void 0, function () {
        var globExpression, stdout, fileCount;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    globExpression = 'test/fixtures/*.md';
                    return [4 /*yield*/, runWithArguments("--files ".concat(globExpression))];
                case 1:
                    stdout = (_a.sent()).stdout;
                    return [4 /*yield*/, glob(globExpression)];
                case 2:
                    fileCount = (_a.sent()).length;
                    stdout.should.include("Spellchecking ".concat(fileCount, " file").concat(fileCount === 1 ? '' : 's', "..."));
                    return [2 /*return*/];
            }
        });
    }); });
    it('exits with no error when passed an empty list of plugins', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('--files a b c --plugins')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    result.stdout.should.equal('Spellchecking 0 files...\n');
                    return [2 /*return*/];
            }
        });
    }); });
    it('exits with an error when passed unknown plugins', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stderr;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('--files a b c --plugins d e f')];
                case 1:
                    _a = _b.sent(), code = _a.code, stderr = _a.stderr;
                    code.should.equal(1);
                    stderr.should.include('The following retext plugins are not supported: d, e, f.');
                    return [2 /*return*/];
            }
        });
    }); });
    it('applies all default plugins by default', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stdout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments("--files test/fixtures/{{".concat(nonSpellPlugins.join(','), "}.md,incorrect.txt}"))];
                case 1:
                    _a = _b.sent(), code = _a.code, stdout = _a.stdout;
                    code.should.equal(1);
                    stdout.should.include('retext-spell');
                    stdout.should.not.include('test/fixtures/incorrect.txt: no issues found');
                    nonSpellAddPlugins.forEach(function (plugin) {
                        stdout.should.include("retext-".concat(plugin));
                    });
                    nonSpellRemovePlugins.forEach(function (plugin) {
                        stdout.should.include("test/fixtures/".concat(plugin, ".md: no issues found"));
                    });
                    return [2 /*return*/];
            }
        });
    }); });
    it('applies all the specified plugins', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stdout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments("--files test/fixtures/{".concat(nonSpellPlugins.join(','), "}.md --plugins ").concat(nonSpellPlugins.join(' ')))];
                case 1:
                    _a = _b.sent(), code = _a.code, stdout = _a.stdout;
                    code.should.equal(1);
                    nonSpellAddPlugins.forEach(function (plugin) {
                        stdout.should.include("retext-".concat(plugin));
                    });
                    nonSpellRemovePlugins.forEach(function (plugin) {
                        stdout.should.include("test/fixtures/".concat(plugin, ".md: no issues found"));
                    });
                    return [2 /*return*/];
            }
        });
    }); });
    it("doesn't apply plugins that aren't specified on the command line", function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('--files test/fixtures/repeated-words.md --plugins spell')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it("doesn't apply plugins that aren't specified in a config file", function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('--files test/fixtures/repeated-words.md --config test/fixtures/config/spell-only.yml')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('applies retext-indefinite-article when it is specified', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stdout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/indefinite-article.md -p indefinite-article')];
                case 1:
                    _a = _b.sent(), code = _a.code, stdout = _a.stdout;
                    code.should.equal(1);
                    stdout.should.include('Use `an` before `8-year`, not `a`');
                    stdout.should.include('Use `an` before `hour`, not `a`');
                    stdout.should.include('Use `a` before `European`, not `an`');
                    return [2 /*return*/];
            }
        });
    }); });
    it('applies retext-repeated-words when it is specified', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stdout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/repeated-words.md -p repeated-words')];
                case 1:
                    _a = _b.sent(), code = _a.code, stdout = _a.stdout;
                    code.should.equal(1);
                    stdout.should.include('Expected `it` once, not twice');
                    stdout.should.include('Expected `to` once, not twice');
                    stdout.should.include('Expected `the` once, not twice');
                    return [2 /*return*/];
            }
        });
    }); });
    it('applies retext-syntax-mentions when it is specified', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/syntax-mentions.md -p syntax-mentions')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('applies retext-syntax-urls when it is specified', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/syntax-urls.md -p syntax-urls')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('ignores the frontmatter if no keys are given', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/frontmatter-incorrect.md -p spell frontmatter')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('ignores the frontmatter if no keys are given (toml)', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/frontmatter-incorrect-toml.md -p spell frontmatter')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('checks only the given keys in the frontmatter (1)', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stdout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/frontmatter-incorrect.md -p spell frontmatter --frontmatter-keys contributors')];
                case 1:
                    _a = _b.sent(), code = _a.code, stdout = _a.stdout;
                    code.should.equal(1);
                    stdout.should.include('`tbroadley` is misspelt');
                    stdout.should.not.include('`documnet` is misspelt');
                    return [2 /*return*/];
            }
        });
    }); });
    it('checks only the given keys in the frontmatter (2)', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stdout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/frontmatter-incorrect.md -p spell frontmatter --frontmatter-keys title')];
                case 1:
                    _a = _b.sent(), code = _a.code, stdout = _a.stdout;
                    code.should.equal(1);
                    stdout.should.include('`documnet` is misspelt');
                    stdout.should.not.include('`tbroadley` is misspelt');
                    return [2 /*return*/];
            }
        });
    }); });
    it('checks only the given keys in the frontmatter (3)', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stdout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/frontmatter-incorrect.md -p spell frontmatter --frontmatter-keys title contributors')];
                case 1:
                    _a = _b.sent(), code = _a.code, stdout = _a.stdout;
                    code.should.equal(1);
                    stdout.should.include('`documnet` is misspelt');
                    stdout.should.include('`tbroadley` is misspelt');
                    return [2 /*return*/];
            }
        });
    }); });
    it('checks only the given keys in the frontmatter (toml) (1)', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stdout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/frontmatter-incorrect-toml.md -p spell frontmatter --frontmatter-keys contributors')];
                case 1:
                    _a = _b.sent(), code = _a.code, stdout = _a.stdout;
                    code.should.equal(1);
                    stdout.should.include('`tbroadley` is misspelt');
                    stdout.should.not.include('`documnet` is misspelt');
                    return [2 /*return*/];
            }
        });
    }); });
    it('checks only the given keys in the frontmatter (toml) (2)', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stdout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/frontmatter-incorrect-toml.md -p spell frontmatter --frontmatter-keys title')];
                case 1:
                    _a = _b.sent(), code = _a.code, stdout = _a.stdout;
                    code.should.equal(1);
                    stdout.should.include('`documnet` is misspelt');
                    stdout.should.not.include('`tbroadley` is misspelt');
                    return [2 /*return*/];
            }
        });
    }); });
    it('checks only the given keys in the frontmatter (toml) (3)', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stdout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/frontmatter-incorrect-toml.md -p spell frontmatter --frontmatter-keys title contributors')];
                case 1:
                    _a = _b.sent(), code = _a.code, stdout = _a.stdout;
                    code.should.equal(1);
                    stdout.should.include('`documnet` is misspelt');
                    stdout.should.include('`tbroadley` is misspelt');
                    return [2 /*return*/];
            }
        });
    }); });
    it('does not generate a personal dictionary if no spelling mistakes are found', function () { return __awaiter(_this, void 0, void 0, function () {
        var stdout;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/repeated-words.md --plugins spell repeated-words --generate-dictionary')];
                case 1:
                    stdout = (_a.sent()).stdout;
                    stdout.should.not.include('Personal dictionary written to dictionary.txt.');
                    return [2 /*return*/];
            }
        });
    }); });
    it('does not generate a personal dictionary if the argument is not passed', function () { return __awaiter(_this, void 0, void 0, function () {
        var stdout;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/incorrect.txt --plugins spell')];
                case 1:
                    stdout = (_a.sent()).stdout;
                    stdout.should.not.include('Personal dictionary written to dictionary.txt.');
                    return [2 /*return*/];
            }
        });
    }); });
    it('supports multiple dictionaries', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/incorrect-2.txt --dictionaries test/fixtures/dictionaries/one.txt test/fixtures/dictionaries/two.txt')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('supports CommonJS programmatic dictionaries', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/incorrect.txt --dictionaries test/fixtures/dictionaries/programmatic.cjs')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('supports ES module programmatic dictionaries', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/incorrect.txt --dictionaries test/fixtures/dictionaries/programmatic.js')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('loads programmatic dictionaries relative to the current working directory', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runCommand('cd test && node ../build/index.js fixtures/incorrect.txt --dictionaries fixtures/dictionaries/programmatic.cjs')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('supports specifying both non-programmatic and programmatic dictionaries', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/incorrect-2.txt --dictionaries test/fixtures/dictionaries/programmatic.cjs test/fixtures/dictionaries/two.txt')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('treats dictionary entries as regexes', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/incorrect.txt --dictionaries test/fixtures/dictionaries/regex.txt')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('treats dictionary entries as if they were wrapped in ^ and $', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stdout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/incorrect.txt --dictionaries test/fixtures/dictionaries/regex-no-match.txt')];
                case 1:
                    _a = _b.sent(), code = _a.code, stdout = _a.stdout;
                    code.should.equal(1);
                    stdout.should.include('`Thisisnotaword` is misspelt');
                    stdout.should.include('`preprocessed` is misspelt');
                    return [2 /*return*/];
            }
        });
    }); });
    it('supports programmatic dictionaries that pass mixed regexes and strings', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/incorrect.txt --dictionaries test/fixtures/dictionaries/regex.cjs')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('supports programmatic dictionaries that contain case-insensitive regexes', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/incorrect-case-insensitive.txt --dictionaries test/fixtures/dictionaries/regex.cjs')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('ignores spelling mistakes that match the given regexes', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/incorrect.txt --ignore "Thisisnot.*" "(pre)?processed"')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('does not ignore spelling mistakes that do not match any of the given regexes', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stdout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/incorrect.txt --ignore "Thisisnot" "processed"')];
                case 1:
                    _a = _b.sent(), code = _a.code, stdout = _a.stdout;
                    code.should.equal(1);
                    stdout.should.include('`Thisisnotaword` is misspelt');
                    stdout.should.include('`preprocessed` is misspelt');
                    return [2 /*return*/];
            }
        });
    }); });
    it('does not limit number of reported misspelling errors', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stdout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/gibberish-50-lines.txt')];
                case 1:
                    _a = _b.sent(), code = _a.code, stdout = _a.stdout;
                    code.should.equal(1);
                    stdout.should.include('50 warnings');
                    stdout.should.not.include('Too many misspellings');
                    return [2 /*return*/];
            }
        });
    }); });
    it('does not show overflow error for ignored patterns', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/gibberish-50-lines.txt --ignore "nm[0-9]+a"')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    result.stdout.should.not.include('Too many misspellings');
                    result.stdout.should.include('no issues found');
                    return [2 /*return*/];
            }
        });
    }); });
    it('enables suggestions by default', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stdout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/incorrect.txt')];
                case 1:
                    _a = _b.sent(), code = _a.code, stdout = _a.stdout;
                    code.should.equal(1);
                    stdout.should.include('`preprocessed` is misspelt; did you mean `reprocessed`?');
                    return [2 /*return*/];
            }
        });
    }); });
    it('allows suggestions to be disabled', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stdout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/incorrect.txt --no-suggestions')];
                case 1:
                    _a = _b.sent(), code = _a.code, stdout = _a.stdout;
                    code.should.equal(1);
                    stdout.should.include('`preprocessed` is misspelt');
                    stdout.should.not.include('`preprocessed` is misspelt; did you mean `reprocessed`?');
                    return [2 /*return*/];
            }
        });
    }); });
    it('does not flag Unicode emoji variation selectors as spelling errors', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/emoji.txt')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('ignores spelling mistakes inside exclude comment blocks', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/exclude-blocks.md')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('catch spelling mistakes inside incomplete exclude comment blocks', function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, code, stdout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/exclude-blocks-incorrect.md')];
                case 1:
                    _a = _b.sent(), code = _a.code, stdout = _a.stdout;
                    code.should.equal(1);
                    stdout.should.include('`iinside` is misspelt');
                    return [2 /*return*/];
            }
        });
    }); });
    it('ignores spelling mistakes inside single-line exclude comments', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/exclude-blocks-singleline.md')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('ignores spelling mistakes inside exclude comment blocks with special formatting', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('test/fixtures/exclude-blocks-formatting.md')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('can read options from a YAML config file', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('--config test/fixtures/config/basic.yml')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('can read options from a JSON config file', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('--config test/fixtures/config/basic.json')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
    it('can read options from a JSONC config file', function () { return __awaiter(_this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, runWithArguments('--config test/fixtures/config/basic.jsonc')];
                case 1:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [2 /*return*/];
            }
        });
    }); });
});
describe('Spellchecker CLI (not parallel)', function () {
    it('exits with an error when no arguments are provided', function () { return __awaiter(void 0, void 0, void 0, function () {
        var config, _a, code, stderr;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    config = readFileSync('.spellcheckerrc.yml', { encoding: 'utf8' });
                    rmSync('.spellcheckerrc.yml');
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, , 3, 4]);
                    return [4 /*yield*/, runWithArguments('')];
                case 2:
                    _a = _b.sent(), code = _a.code, stderr = _a.stderr;
                    code.should.equal(1);
                    stderr.should.include('A list of files is required.');
                    return [3 /*break*/, 4];
                case 3:
                    writeFileSync('.spellcheckerrc.yml', config);
                    return [7 /*endfinally*/];
                case 4: return [2 /*return*/];
            }
        });
    }); });
    it('generates a personal dictionary if spelling mistakes are found and argument is passed', function () { return __awaiter(void 0, void 0, void 0, function () {
        var dictionary, stdout;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    dictionary = readFileSync('dictionary.txt', { encoding: 'utf8' });
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, , 3, 4]);
                    return [4 /*yield*/, runWithArguments('test/fixtures/incorrect.txt --plugins spell --generate-dictionary')];
                case 2:
                    stdout = (_a.sent()).stdout;
                    stdout.should.include('Personal dictionary written to dictionary.txt.');
                    readFileSync('dictionary.txt', 'utf8').should.equal('Thisisnotaword\npreprocessed\n');
                    return [3 /*break*/, 4];
                case 3:
                    writeFileSync('dictionary.txt', dictionary);
                    return [7 /*endfinally*/];
                case 4: return [2 /*return*/];
            }
        });
    }); });
    it('writes personal dictionary to given path', function () { return __awaiter(void 0, void 0, void 0, function () {
        var stdout;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, , 2, 3]);
                    return [4 /*yield*/, runWithArguments('test/fixtures/incorrect.txt --plugins spell --generate-dictionary test/dictionary.txt')];
                case 1:
                    stdout = (_a.sent()).stdout;
                    stdout.should.include('Personal dictionary written to test/dictionary.txt.');
                    readFileSync('test/dictionary.txt', 'utf8').should.equal('Thisisnotaword\npreprocessed\n');
                    return [3 /*break*/, 3];
                case 2:
                    rmSync('test/dictionary.txt');
                    return [7 /*endfinally*/];
                case 3: return [2 /*return*/];
            }
        });
    }); });
    it('exits with an error when run on a file that is included in the .gitignore and the --no-gitignore flag is passed', function () { return __awaiter(void 0, void 0, void 0, function () {
        var createFileResult, _a, code, stdout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, , 3, 4]);
                    return [4 /*yield*/, runCommand('echo "This file contians a misspelled word." > test/fixtures/gitignored-file.txt')];
                case 1:
                    createFileResult = _b.sent();
                    createFileResult.should.not.have.property('code');
                    return [4 /*yield*/, runWithArguments('--no-gitignore --files test/fixtures/gitignored-file.txt')];
                case 2:
                    _a = _b.sent(), code = _a.code, stdout = _a.stdout;
                    code.should.equal(1);
                    stdout.should.include('`contians` is misspelt');
                    return [3 /*break*/, 4];
                case 3:
                    rmSync('test/fixtures/gitignored-file.txt');
                    return [7 /*endfinally*/];
                case 4: return [2 /*return*/];
            }
        });
    }); });
    it('exits with no error when run on a file that is included in the .gitignore', function () { return __awaiter(void 0, void 0, void 0, function () {
        var createFileResult, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, , 3, 4]);
                    return [4 /*yield*/, runCommand('echo "This file contians a misspelled word." > test/fixtures/gitignored-file.txt')];
                case 1:
                    createFileResult = _a.sent();
                    createFileResult.should.not.have.property('code');
                    return [4 /*yield*/, runWithArguments('--files test/fixtures/gitignored-file.txt')];
                case 2:
                    result = _a.sent();
                    result.should.not.have.property('code');
                    return [3 /*break*/, 4];
                case 3:
                    rmSync('test/fixtures/gitignored-file.txt');
                    return [7 /*endfinally*/];
                case 4: return [2 /*return*/];
            }
        });
    }); });
});
